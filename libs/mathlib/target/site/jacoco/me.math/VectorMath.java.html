<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>VectorMath.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mathlib</a> &gt; <a href="index.source.html" class="el_package">me.math</a> &gt; <span class="el_source">VectorMath.java</span></div><h1>VectorMath.java</h1><pre class="source lang-java linenums">//	  CIRAS: Crime Information Retrieval and Analysis System
//    Copyright 2009 by Russ Brasser, Mark Everline and Eric Franklin
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

package me.math;

//Written by Kyle Slattery (http://kyleslattery.com)
//Free to use and edit, so long as above line stays intact
public class VectorMath {
	private double x,y,z;
	private double magnitude;

	private VectorMath unit;

<span class="fc" id="L27">	public VectorMath(boolean isUnit, double x, double y, double z) {</span>
<span class="fc" id="L28">		this.x = x;</span>
<span class="fc" id="L29">		this.y = y;</span>
<span class="fc" id="L30">		this.z = z;</span>

<span class="fc" id="L32">		magnitude = Math.sqrt(x * x + y * y + z * z);</span>

<span class="fc bfc" id="L34" title="All 2 branches covered.">		if (isUnit) {</span>
<span class="fc" id="L35">			this.unit = this;</span>

		} else {
<span class="fc bfc" id="L38" title="All 2 branches covered.">			if (magnitude == 0) {</span>
<span class="fc" id="L39">				this.unit = new VectorMath(true, 0, 0, 0);</span>
			} else {
<span class="fc" id="L41">				this.unit = new VectorMath(true, x / magnitude, y / magnitude,</span>
						z / magnitude);
			}
		}
<span class="fc" id="L45">	}</span>

	public VectorMath(double x, double y, double z) {

<span class="fc" id="L49">		this(false, x, y, z);</span>
<span class="fc" id="L50">	}</span>

	// Accessor Methods
	public double getX() {
<span class="fc" id="L54">		return x;</span>
	}

	public double getY() {
<span class="fc" id="L58">		return y;</span>
	}

	public double getZ() {
<span class="fc" id="L62">		return z;</span>
	}

	public double getMagnitude() {
<span class="fc" id="L66">		return magnitude;</span>
	}

	public VectorMath getUnitVector() {
<span class="fc" id="L70">		return unit;</span>
	}

	// Operations
	public VectorMath scalarMult(double scalar) {
<span class="fc" id="L75">		return new VectorMath(x * scalar, y * scalar, z * scalar);</span>
	}

	public VectorMath add(VectorMath vec) {
<span class="fc" id="L79">		return new VectorMath(x + vec.getX(), y + vec.getY(), z + vec.getZ());</span>
	}

	public VectorMath subtract(VectorMath v) {
<span class="fc" id="L83">		return (new VectorMath(getX() - v.getX(), getY() - v.getY(), getZ()</span>
<span class="fc" id="L84">				- v.getZ()));</span>
	}

	public VectorMath add(VectorMath[] vec) {
		double x2, y2, z2;
<span class="fc" id="L89">		x2 = y2 = z2 = 0;</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">		for (VectorMath vectorMath : vec) {</span>
<span class="fc" id="L91">			x2 += vectorMath.getX();</span>
<span class="fc" id="L92">			y2 += vectorMath.getY();</span>
<span class="fc" id="L93">			z2 += vectorMath.getZ();</span>
		}

<span class="fc" id="L96">		return new VectorMath(x + x2, y + y2, z + z2);</span>
	}

	public double dot(VectorMath vec) {
<span class="fc" id="L100">		return x*vec.getX() + y*vec.getY() + z*vec.getZ();</span>
	}

	public double norm() {
<span class="fc" id="L104">		return Math.sqrt(Math.abs(Math.pow(getX(), 2))</span>
<span class="fc" id="L105">						 + Math.abs(Math.pow(getY(), 2))</span>
<span class="fc" id="L106">						 + Math.abs(Math.pow(getZ(), 2)));</span>
	}

	public VectorMath cross(VectorMath vec) {
<span class="fc" id="L110">		double xi = y*vec.getZ() - z*vec.getY();</span>
<span class="fc" id="L111">		double yi = z*vec.getX() - x*vec.getZ();</span>
<span class="fc" id="L112">		double zi = x*vec.getY() - y*vec.getX();</span>
<span class="fc" id="L113">		return new VectorMath(xi,yi,zi);</span>

	}

    public double angle( VectorMath v)
    {
<span class="fc" id="L119">        VectorMath uHat = getUnitVector();</span>
<span class="fc" id="L120">        VectorMath vHat = v.getUnitVector();</span>

<span class="fc bfc" id="L122" title="All 2 branches covered.">        if( uHat.dot(vHat) &lt; 0.0)</span>
        {
<span class="fc" id="L124">            VectorMath w = vHat.subtract(uHat).scalarMult(-1.0);</span>

<span class="fc" id="L126">            return Math.PI - 2 * Math.asin(w.getMagnitude() / 2.0);</span>
        }
        else
        {
<span class="fc" id="L130">            VectorMath w = vHat.subtract(uHat);</span>
<span class="fc" id="L131">            return 2 * Math.asin(w.getMagnitude() / 2);</span>
        }
    }

    public VectorMath unit() {
<span class="fc" id="L136">		double m = this.getMagnitude();</span>
<span class="fc" id="L137">		return new VectorMath(getX() / m, getY() / m, getZ() / m);</span>
	}

	public VectorMath minus(VectorMath vec) {
<span class="fc" id="L141">		return new VectorMath(x-vec.getX(), y-vec.getY(), z-vec.getZ());</span>
	}

    public VectorMath fromHereToThere(VectorMath here) {
		// here + hereToThere = there
		// hereToThere = there - here
<span class="fc" id="L147">		return here.subtract(this);</span>
	}

	public double distance(VectorMath there) {
		// here + hereToThere = there
		// hereToThere = there - here
<span class="fc" id="L153">		double dx = there.getX() - getX();</span>
<span class="fc" id="L154">		double dy = there.getY() - getY();</span>
<span class="fc" id="L155">		double dz = there.getZ() - getZ();</span>

<span class="fc" id="L157">		return Math.sqrt(dx * dx + dy * dy + dz * dz);</span>
	}

	public String toString() {
<span class="fc" id="L161">		return &quot;&lt;&quot; + x + &quot;, &quot; + y + &quot;, &quot; + z + &quot;&gt;&quot;;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>