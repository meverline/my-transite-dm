<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractTiledSpatialGrid.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mathlib</a> &gt; <a href="index.source.html" class="el_package">me.math.grid.tiled</a> &gt; <span class="el_source">AbstractTiledSpatialGrid.java</span></div><h1>AbstractTiledSpatialGrid.java</h1><pre class="source lang-java linenums">package me.math.grid.tiled;

import java.net.UnknownHostException;
import java.sql.SQLException;

import javax.persistence.Column;

import me.math.LocalDownFrame;
import me.math.VectorMath;
import me.math.Vertex;
import me.math.grid.AbstractSpatialGridOverlay;
import me.math.grid.AbstractSpatialGridPoint;
import me.math.kdtree.INode;
import me.math.kdtree.INode.Direction;
import me.math.kdtree.INodeCreator;
import me.math.kdtree.KDTree;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonSubTypes.Type;

@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = &quot;type&quot;)
@JsonSubTypes({
		@Type(value = SpatialTile.class, name = &quot;SpatialTile&quot;),
		@Type(value = TiledSpatialGrid.class, name = &quot;TiledSpatialGrid&quot;)})
<span class="fc" id="L29">public abstract class AbstractTiledSpatialGrid extends AbstractSpatialGridOverlay implements INodeCreator {</span>
	

<span class="fc" id="L32">	private Log logger = LogFactory.getLog(TiledSpatialGrid.class);</span>

<span class="fc" id="L34">	@Column(name=&quot;tileSize&quot; )</span>
	private int tileSize = 32;
	
	/**
	 * 
	 * @param index
	 * @param row
	 * @param col
	 * @return
	 */
	public abstract TiledSpatialGridPoint get(int index, int row, int col) throws UnknownHostException;

	/**
	 * 
	 * @param index
	 * @param gridIndex
	 * @return
	 */
	public abstract AbstractSpatialGridPoint get(int index, int gridIndex);

	/**
	 * 
	 * @param tile
	 */
	protected abstract void addTile(SpatialTile tile) throws UnknownHostException, SQLException;

	/**
	 * 
	 * @param row
	 * @param column
	 * @return
	 * @throws UnknownHostException 
	 */
	public TiledSpatialGridPoint getEntry(int row, int column) throws UnknownHostException {
<span class="fc" id="L68">		int colWidth = (this.getCols() / this.getTileSize()) +1;</span>
<span class="fc" id="L69">		int index = ((row / this.getTileSize()) * colWidth) + (column / this.getTileSize());</span>
<span class="fc" id="L70">		return get(index, row, column);</span>
	}
		
	/**
	 * 
	 * @param index
	 * @return
	 * @throws UnknownHostException 
	 */
    public AbstractSpatialGridPoint getEntry(int index) throws UnknownHostException {
<span class="fc" id="L80">    	int size = (this.getTileSize() * this.getTileSize()); </span>
<span class="fc" id="L81">    	return this.get(index/size, index);</span>
	}

	/**
	 * Create a uniform lat/lon grid.
	 * @param upperLeft
	 * @param lowerRight
	 * @throws UnknownHostException 
	 * @throws SQLException 
	 */
	protected void createGrid(Vertex upperLeft, Vertex lowerRight) throws UnknownHostException, SQLException {

<span class="fc" id="L93">		Vertex lowerLeft = new Vertex(lowerRight.getLatitudeDegress(),</span>
<span class="fc" id="L94">									  upperLeft.getLongitudeDegress());</span>

<span class="fc" id="L96">		this.setCols(findNumberOfCols(upperLeft, lowerRight, getGridSpacingMeters()));</span>
<span class="fc" id="L97">		this.setRows(findNumberOfRows(upperLeft, lowerRight, getGridSpacingMeters()));</span>
		
		
		// find number of tiles
<span class="fc" id="L101">		int totalColTiles = 0;</span>
<span class="fc" id="L102">		int totalRowTiles = 0;</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">		for (int rowIndex = 0; rowIndex &lt; this.getRows(); rowIndex += this.tileSize) {</span>
<span class="fc" id="L104">			totalColTiles = 0;</span>
<span class="fc" id="L105">			totalRowTiles++;</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">			for (int colIndex = 0; colIndex &lt; this.getCols(); colIndex += this.tileSize ) {</span>
<span class="fc" id="L107">				totalColTiles++;</span>
			}
		}
		
<span class="fc" id="L111">		int tilesCols = totalColTiles * this.tileSize;</span>
<span class="fc" id="L112">		int tilesRows = totalRowTiles * this.tileSize;</span>
		
<span class="fc" id="L114">		logger.info(getClass().getSimpleName() + &quot; Rows: &quot; +  this.getRows() </span>
<span class="fc" id="L115">											   + &quot; Cols: &quot; + this.getCols()</span>
<span class="fc" id="L116">											   + &quot; Num Cells &quot; + (this.getRows() * this.getCols())</span>
											   + &quot; Tile Cols &quot; + tilesCols + &quot; Tile Row &quot;+ tilesRows);

		
<span class="fc" id="L120">		double northDistanceMeters = (double) tilesRows* this.getGridSpacingMeters();</span>
<span class="fc" id="L121">		double eastDistanceMeters = (double) tilesCols* this.getGridSpacingMeters();</span>
		
<span class="fc" id="L123">		LocalDownFrame southWestFrame = new LocalDownFrame(lowerLeft.getEcfFromLatLon());</span>

<span class="fc" id="L125">		VectorMath newPos = southWestFrame.getRelativePosition( northDistanceMeters,</span>
																eastDistanceMeters,
																LocalDownFrame.RelativePositionOrder.NORTH_THEN_EAST);
<span class="fc" id="L128">		Vertex gridlowerRight = Vertex.getLatLonFromEcf(newPos); </span>
<span class="fc" id="L129">		CrossCovData data = new CrossCovData(findAverageLatLon(upperLeft, gridlowerRight));</span>
       
<span class="fc" id="L131">		int index = 0;</span>
<span class="fc" id="L132">		int tileIndex = 0;</span>
		
<span class="fc bfc" id="L134" title="All 2 branches covered.">		for (int rowIndex = 0; rowIndex &lt; this.getRows(); rowIndex += this.tileSize) {</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">			for (int colIndex = 0; colIndex &lt; this.getCols(); colIndex += this.tileSize ) {</span>
<span class="fc" id="L136">				SpatialTile tile = new SpatialTile(rowIndex, colIndex, index, tileIndex++);</span>
<span class="fc" id="L137">				tile.createGrid(tileSize, tileSize, southWestFrame, this.getGridSpacingMeters(), data);</span>
<span class="fc" id="L138">				this.addTile(tile);</span>
<span class="fc" id="L139">				index += this.tileSize * this.tileSize;</span>
			}
		}
		
<span class="fc" id="L143">		this.setCrossCovariance(data.crossCovariance());</span>
<span class="fc" id="L144">	}</span>

	public INode create(AbstractSpatialGridPoint loc, Direction dir, INode parent, int depth) {
<span class="nc" id="L147">		TiledSpatialGridPoint rtn = null;</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">		if ( loc instanceof TiledSpatialGridPoint ) {</span>
<span class="nc" id="L149">			rtn = TiledSpatialGridPoint.class.cast(loc);</span>
<span class="nc" id="L150">			rtn.setDepth(depth);</span>
<span class="nc" id="L151">			rtn.setParent(parent);</span>
<span class="nc" id="L152">			rtn.setDirection(dir);</span>
		}
<span class="nc" id="L154">		return rtn;</span>
	}
		
	/**
	 * 
	 * @return
	 */
	@Column(name=&quot;tileSize&quot;)
	public int getTileSize()
	{
<span class="fc" id="L164">		return this.tileSize;</span>
	}
	
	protected void setTileSize(int value)
	{
<span class="nc" id="L169">		this.tileSize = value;</span>
<span class="nc" id="L170">	}</span>
	
	/**
	 * 
	 * @return
	 */
	public KDTree getTree() {
<span class="fc" id="L177">		throw new IllegalArgumentException(&quot;opration not supported&quot;);</span>
	}

	@Override
	public AbstractSpatialGridPoint getNextGridPoint(
			AbstractSpatialGridPoint gridPt) {
<span class="fc" id="L183">		throw new UnsupportedOperationException();</span>
	}
	
	///////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////
	
	public static class CrossCovData {
		
<span class="fc" id="L192">	   private double d_latitude = 0.0;</span>
<span class="fc" id="L193">	   private double d_longitude = 0.0;</span>
<span class="fc" id="L194">       private int number = 0;</span>
       private final Vertex avgPoint;
       
<span class="fc" id="L197">       public CrossCovData(Vertex pt) {</span>
<span class="fc" id="L198">    	   avgPoint = pt;</span>
<span class="fc" id="L199">       }</span>
        
       public void addPoint(Vertex pt) {
<span class="fc" id="L202">    	   number++;</span>
<span class="fc" id="L203">    	   d_latitude += pt.getLatitudeDegress() - avgPoint.getLatitudeDegress();</span>
<span class="fc" id="L204">           d_longitude += pt.getLongitudeDegress() - avgPoint.getLongitudeDegress();</span>
<span class="fc" id="L205">       }</span>
       
       public double crossCovariance() {
<span class="fc" id="L208">           d_latitude = d_latitude / ( number - 1.0);</span>
<span class="fc" id="L209">           d_longitude = d_longitude / ( number - 1.0);</span>
<span class="fc" id="L210">           return Math.abs((d_latitude * d_longitude) / ( number - 1.0));</span>
       }
       
	}
	
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>